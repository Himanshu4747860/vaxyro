
import requests
import re
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup

def ai_vulnerability_scan(url):
    try:
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url
            
        results = []
        vulnerabilities = []
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        # Get initial response
        response = requests.get(url, headers=headers, timeout=10, allow_redirects=True)
        
        # Security Header Analysis
        security_headers = {
            'X-Frame-Options': 'Clickjacking protection',
            'X-Content-Type-Options': 'MIME sniffing protection',
            'X-XSS-Protection': 'XSS protection',
            'Strict-Transport-Security': 'HTTPS enforcement',
            'Content-Security-Policy': 'Content injection protection',
            'Referrer-Policy': 'Referrer information control'
        }
        
        missing_headers = []
        for header, description in security_headers.items():
            if header not in response.headers:
                missing_headers.append(f"‚ùå Missing {header} ({description})")
            else:
                results.append(f"‚úÖ {header}: {response.headers[header]}")
        
        if missing_headers:
            results.append("\n--- Missing Security Headers ---")
            results.extend(missing_headers)
        
        # SSL/TLS Analysis
        if url.startswith('https://'):
            results.append("\n--- SSL/TLS Analysis ---")
            results.append("‚úÖ HTTPS enabled")
        else:
            vulnerabilities.append("üî¥ HIGH: No HTTPS encryption")
        
        # Common Vulnerability Checks
        content = response.text
        
        # Check for sensitive information exposure
        sensitive_patterns = {
            'Email addresses': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            'IP addresses': r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b',
            'API keys': r'(?i)(api[_-]?key|access[_-]?token|secret[_-]?key)[\s]*[:=][\s]*["\']?([a-z0-9_-]+)["\']?',
            'Database strings': r'(?i)(mysql|postgresql|mongodb|redis)://[^\s<>"\']+',
        }
        
        for pattern_name, pattern in sensitive_patterns.items():
            matches = re.findall(pattern, content)
            if matches:
                vulnerabilities.append(f"üü° MEDIUM: {pattern_name} exposed in source code")
        
        # Check for common XSS vulnerabilities
        soup = BeautifulSoup(content, 'html.parser')
        
        # Look for forms without CSRF protection
        forms = soup.find_all('form')
        for form in forms:
            if not form.find('input', {'name': re.compile(r'csrf|token', re.I)}):
                vulnerabilities.append("üü° MEDIUM: Form without CSRF protection detected")
                break
        
        # Check for inline JavaScript (potential XSS)
        inline_scripts = soup.find_all('script', string=True)
        if inline_scripts:
            vulnerabilities.append("üü° MEDIUM: Inline JavaScript detected (potential XSS risk)")
        
        # Check for HTTP methods
        try:
            options_response = requests.options(url, headers=headers, timeout=5)
            allowed_methods = options_response.headers.get('Allow', '')
            if 'PUT' in allowed_methods or 'DELETE' in allowed_methods:
                vulnerabilities.append("üü° MEDIUM: Potentially dangerous HTTP methods allowed")
        except:
            pass
        
        # Directory traversal check
        test_paths = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '/etc/passwd'
        ]
        
        for test_path in test_paths:
            try:
                test_url = urljoin(url, test_path)
                test_response = requests.get(test_url, headers=headers, timeout=5)
                if 'root:' in test_response.text or 'localhost' in test_response.text:
                    vulnerabilities.append("üî¥ HIGH: Directory traversal vulnerability detected")
                    break
            except:
                continue
        
        # SQL Injection basic check
        sql_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --"]
        for payload in sql_payloads:
            try:
                test_url = f"{url}?id={payload}"
                test_response = requests.get(test_url, headers=headers, timeout=5)
                error_patterns = [
                    'mysql_fetch_array',
                    'ORA-01756',
                    'Microsoft OLE DB Provider',
                    'PostgreSQL query failed',
                    'SQLite3::',
                    'sqlite3.OperationalError'
                ]
                for error_pattern in error_patterns:
                    if error_pattern.lower() in test_response.text.lower():
                        vulnerabilities.append("üî¥ HIGH: Potential SQL injection vulnerability")
                        break
                if vulnerabilities and "SQL injection" in vulnerabilities[-1]:
                    break
            except:
                continue
        
        # Technology fingerprinting for known vulnerabilities
        tech_stack = []
        
        # Server headers
        server = response.headers.get('Server', '')
        if server:
            tech_stack.append(f"Server: {server}")
        
        # Framework detection
        frameworks = {
            'WordPress': r'wp-content|wp-includes',
            'Joomla': r'joomla|com_content',
            'Drupal': r'drupal\.org|/sites/default',
            'Django': r'csrfmiddlewaretoken',
            'Laravel': r'laravel_session'
        }
        
        for framework, pattern in frameworks.items():
            if re.search(pattern, content, re.I):
                tech_stack.append(f"Framework: {framework}")
                # Add framework-specific security recommendations
                if framework == 'WordPress':
                    results.append("üí° WordPress detected - ensure plugins/themes are updated")
                elif framework == 'Joomla':
                    results.append("üí° Joomla detected - check administrator access restrictions")
        
        if tech_stack:
            results.append("\n--- Technology Stack ---")
            results.extend(tech_stack)
        
        # AI-powered risk assessment
        risk_score = 0
        for vuln in vulnerabilities:
            if "HIGH" in vuln:
                risk_score += 3
            elif "MEDIUM" in vuln:
                risk_score += 2
            elif "LOW" in vuln:
                risk_score += 1
        
        # Risk assessment
        if risk_score == 0:
            risk_level = "üü¢ LOW"
            risk_desc = "No major vulnerabilities detected"
        elif risk_score <= 3:
            risk_level = "üü° MEDIUM"
            risk_desc = "Some security issues identified"
        else:
            risk_level = "üî¥ HIGH"
            risk_desc = "Multiple vulnerabilities detected - immediate action required"
        
        results.append(f"\n--- AI Risk Assessment ---")
        results.append(f"Risk Level: {risk_level}")
        results.append(f"Risk Score: {risk_score}/10")
        results.append(f"Assessment: {risk_desc}")
        
        if vulnerabilities:
            results.append("\n--- Detected Vulnerabilities ---")
            results.extend(vulnerabilities)
        
        # Security recommendations
        recommendations = [
            "üõ°Ô∏è Implement all missing security headers",
            "üîí Use HTTPS for all communications",
            "üîê Implement proper authentication and session management",
            "üßπ Sanitize all user inputs",
            "üìù Regular security audits and penetration testing",
            "üîÑ Keep all frameworks and dependencies updated"
        ]
        
        results.append("\n--- Security Recommendations ---")
        results.extend(recommendations)
        
        return results
    except Exception as e:
        return [f"Error during vulnerability scan: {str(e)}"]
